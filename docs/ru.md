# Dependency Injection Container

Следует стандартам PSR-11, а также PSR-1, PSR-2, PSR-4.

Основные идеи:
- Создание объектов, указанных в конфигурации
- Создание объектов, не указанных в конфигурации (в том числе рекурсивно - на любой уровень вложенности)
- Возможность осуществления вызовов и установки свойств после создания объекта
- Возможность осуществления вызовов и установки свойств по классу/интерфейсу (например, "Aware"-интерфейсы)
- Создание объектов с помощью фабрик
- Алиасы (псевдонимы, теги) для любого сервиса
- Отключаемая возможность анализа зависимостей методов/конструкторов с помощью рефлексии
- Возможность добавить дочерние контейнеры для получения объектов, не описанных в текущем контейнере

## Основные возможности контейнера

Создание объекта контейнера:

```php
$container = new Container();
```

С помощью указания собственных реализаций зависимостей контейнера вы можете расширять или изменять его функциональность.
@TODO: ссылку на [Возможность изменения поведения контейнера](#).

### Добавление описания сервиса - addDefinition

Добавление описания требует указания уникального имени добавляемого сервиса.

```php
$definition = new Definition(SimpleComponent::class);
$definition = $container->addDefinition('simple', $definition);
```

Далее, по указанному имени может быть:
- указана ссылка на описание сервиса
- произведено получение объекта из контейнера
- определено соответствие любого класса и описанного сервиса
- произведено добавление псевдонима к описанию сервиса


### Быстрое добавление описания сервиса - addDefinitionClass

Является аналогом метода ```addDefinition```, но позволяет вместо объекта ```Definition``` передать имя класса:

```php
$definition = $container->addDefinitionClass('simple', SimpleComponent::class);
```

### Добавление скалярного значения - addScalar

Добавление любого значения в контейнер для последующего использования:

```php
$container->addScalar('main_email', 'some@email.com');
```

При попытке получить значение из контейнера по имени вернется указанное значение:

```php
$email = $container->get('main_email');
// $email = 'some@email.com'
```
### Определение соответствия запрашиваемого класса и описанного сервиса - addReference

Возможность указать, что при запросе определенного класса будет возращен объект по описанию, добавленному ранее.

Например, мы добавили описание нашего простейшего сервиса:

```php
$definition = new Definition(SimpleComponent::class);
$definition = $container->addDefinition('simple', $definition);
```

И хотим чтобы при запросе класса ```SimpleComponentInterface::class``` возвращался бы объект, 
созданный с помощью описания (Definition), который мы добавили ранее. 

Указываем соответствие класса ```SimpleComponentInterface::class``` и Definition:

```php
$container->addReference('simple', SimpleComponentInterface::class);
```

Теперь, при запросе объекта по класс ```SimpleComponentInterface::class``` контейнер будет возвращать объект, 
созданный с помощью указанного описания (Definition). 

### Добавление псевдонима (тега) к существующему описанию сервиса - addAlias, addAliases

Возможность указать псевдоним/псевдонимы для существующего описания по имени.

Например, мы добавили описание нашего простейшего сервиса:

```php
$definition = new Definition(SimpleComponent::class);
$definition = $container->addDefinition('simple', $definition);
```

И хотим чтобы при запросе по имени "simple_object" возвращался бы объект, 
созданный с помощью описания (Definition), который мы добавили ранее. 

Добавляем псевдоним:

```php
$container->addAlias('simple', 'simple_object');
```

Теперь, при запросе объекта по имени "simple_object" контейнер будет возвращать объект, 
созданный с помощью указанного описания (Definition). 

Так же поддерживается добавление нескольких псевдонимов (тегов) одновременно:

```php
$container->addAlias('simple', [
    'simple_object',
    'smart'
]);
```

### Добавление конфигурирования объектов определенного вида - addInflection

Позволяют конфигурировать созданные объекты определенного вида:
- Устанавливать свойства
- Выполнять методы

Весьма удобны с "Aware" - интерфейсами.

```php
$inflection = new Inflection(LoggerAwareInterface::class);
$inflection->addCall('setLogger', $myLogger);
$container->addInflection($inflection);
```

### Добавление дочернего контейнера - addDelegate

@TODO

### Возможность вызова методов с автоматической инъекцией зависимостей - invoke

@TODO

### Получение объекта - get

@TODO

### Проверка на возможность получения объекта - has

@TODO

## Объект описания сервиса - Definition

@TODO - конструктор

### Указание аргументов конструктора - addArguments

@TODO - со ссылкой на использование ссылок

### Указание вызова метода после создания объекта - addCall

@TODO

### Указание установки свойства после создания объекта - addProperty

@TODO

### Добавление псевдонима (тега) - addAliases, addAlias

@TODO

### Указание метода-конструктора - setConstructMethod

@TODO

### Указание фабрики для создания объекта - setFactory

@TODO

### Указание, что объект является "общим" (shared) - setShared

@TODO

## Объект конфигурирования объектов определенного вида - Inflection

@TODO

### Указание вызова метода после создания объекта - addCall

@TODO

### Указание установки свойства после создания объекта - addProperty

@TODO

## Использование ссылок на описания сервисов

@TODO: через собаку - где и как, с примерами 

### В аргументах методов и конструкторов

@TODO

### В фабриках

@TODO

## Управление анализом предков и интерфейсов добавляемых классов

@TODO

## Управление созданием объектов, не описанных через объект Definition

@TODO

## Управление анализом аргументов методов и конструкторов

@TODO

## Возможность изменения поведения контейнера

@TODO 